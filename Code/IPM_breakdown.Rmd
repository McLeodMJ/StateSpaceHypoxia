---
title: "IPM breakdown"
author: "Montana McLeod"
date: "1/19/2021"
output: pdf_document
---

```{r setup, include=FALSE}
require("knitr")
opts_knit$set(root.dir = "~/Box Sync/McLeod_thesis/code")
```

# create mesh: sizes that we are running the IPM over
```{r}
# Lingcod 
# Fishing rate is referred to as exploitation rate
source("./Library/params.R")
pars <- params("Lingcod")

# IPM integration parameters:
meshsize = 200
meshmin = 0
meshmax = pars$Linf * 2

x <- seq(from = meshmin, to = meshmax, length.out = meshsize) # different size classes
dx = diff(x)[1] #width of the 'rectangle' to do the midpoint rule *cough cough* left rule

```
# Kernel: transition from size x --> y for different size classes
### K(y,x) = Pg(y,x) + Fe(y,x)
## Survival part of Kernel 
```{r}
### create a mesh grid of size changes
 Size_c = t(matrix(x, nrow=length(x), ncol=length(x))) #- matrix of sizes at t  ## sizes same per column
   
#### Survival part of kernel
  #m=0 #check with mort. =0 
  m= pars$M 
 
### convert to probability
 timestep = 1 # 1yr
 pm <- exp(-m * timestep) # prob. survival
  # increases with size
 pm[pm<0] = 0 # make sure no negatives 
 
 
 #' 1. timestep? how do we decide this?
```

# Growth part of the kernel 
```{r}
### create a mesh grid of size changes
  Size_r = t(Size_c) #- matrix of sizes at t+1 ## sizes same per row

### Growth part of kernel. Do it this way so that we simulate many different growth trajectories in the population, averaged together.
  nLinfs = 1000 # how many different values of Linf to simulate
  
### create Matrices of simulated sizes
  Linfs <- rnorm(n = nLinfs, mean = pars$Linf, (pars$Linf.cv *pars$Linf)) # vector of random dist. of Linfs- max lengths
  Linf_sims <- matrix(Linfs, nrow = nLinfs, ncol = length(x)) # expand into a matrix so there is a corresponding value of Linf for each possible value in the length vector x
  # ^ same values for each column to run against different size distr.
  Size_chge <- t(matrix(x, ncol = nLinfs, nrow = length(x))) # expand x into a matrix so there is a value for each value of Linfs.mat ## size changes per column and goes up to mesh max size 

### Create range of growth rates
  VBlengths <-  Linf_sims - (Linf_sims - Size_chge) * exp(-pars$K * timestep) # VonBert -- use those two matrices to get the range of possible growth rates, as a function of X
  
  VBmean <- colMeans(VBlengths) # Take the mean across all of the different trajectories for each value of x
  Leng_mean <- t(matrix(VBmean, nrow = length(x), ncol = length(x))) # expand into a matrix with a corresponding value for each value of Y (the size at time t+1)
  
  VBsd <- VBmean * (pars$Linf.cv)
  Leng_sd <- t(matrix(VBsd, nrow = length(x), ncol = length(x))) 
 
### convert to probability 
  pg <- dnorm(Size_r, mean = Leng_mean, sd = Leng_sd) # use dnorm to get the distribution of growth rates 
  pg[pg<0] = 0 # make sure no negatives
  
### Run the kernel as prob. death * growth
  K = pm * pg 
  plot(colSums(K)*dx, type='l')
```


# recruitment part of kernel 
## I think this is where we loose the resilence of the IPM
```{r}
### If adding fecundity too:
  Rvec <- dnorm(x, pars$Rlen, pars$Rlen.sd) # size distribution of recruits 

 Fec <- pars$fec.const * Size_c ^(pars$fec.exp)  #leads to much smaller values than sample IPM 
 Fe <- Fec * Rvec # combine the two
  # Fe values are very small although in the right spot, problem????
  plot(colSums(Fe), type= 'l') 
```
 

# run the model 
```{r}
### Initialize the model:
  time = 100
  N = matrix(0, nrow = meshsize, ncol = time) #pop size w/ growth/mortal kernel
  E = matrix(0, nrow = meshsize, ncol = time) #pop size w/ ^^ & fecundity
  
  N[,1] <- Rvec * 2e6 # pars$Rmu  initialize with one pulse of new recruits

  ### Run the model
  for (t in 2:time){
    N[,t] <- K %*% N[,t-1]  * dx  #+  Rvec  * pars$Rmu # midpoint rule integration
     E[,t] <- Fe %*% N[,t-1] * dx

  ### BH step
    ## BH eqn: (Methot and Tylor 2011 - eqn A.7)
    # Ry = 4h*R0*Eggs / S0(1-h) + Eggs(5h -1)
  Eggs = sum(E[,t])*dx 
  
  a =((Eggs/exp(pars$R0))*(1-pars$steep)) / 4*pars$steep
  b=(5*pars$steep -1) / (4*pars$steep *exp(pars$R0))
  Recruits = a * Eggs/(1 + a/b*Eggs)
  #Recruits = a*pars$S0 / (b + pars$S0)
  #Recruits <- (4 * pars$steep * exp(pars$R0) * Eggs) / ((pars$S0 * (1 - pars$steep)) + (Eggs * (5 * pars$steep - 1)))
   N[,t] = N[,t] + Recruits * Rvec 
  }
  
### total population size:
MR <- sum(N[ ,time] * dx)
N0 <- N[,time]

par(mfrow = c(1,2))
plot(x, N[ ,time], type = 'l') #shows hump around Linf
plot(colSums(N), type='l')

#df <- data.frame(Size = x, Frequency = N[, time] / MR)
#ggplot(data = df, aes(x = Size, y = Frequency)) + geom_line()

```



# Test mesh sizes 
```{r}
zzz <- seq(10, 200, by=2)
z <- rep(NA, length = length(zzz))
abund <- rep(NA, length = length(zzz))
for(i in 1:length(zzz)){
    # IPM integration parameters:
     x <- seq(from = meshmin, to = meshmax, length.out = zzz[i]) # different size classes
     Rvec <- dnorm(x, pars$Rlen, pars$Rlen.sd)
     z[i] <- sum(Rvec)
     # this should integrate to unity (1) - does it?
  Size_c = t(matrix(x, nrow=length(x), ncol=length(x))) #- matrix of sizes at t  ## sizes same per column
  
     ### create a mesh grid of size changes
  Size_r = t(Size_c) #- matrix of sizes at t+1 ## sizes same per row

### Growth part of kernel. Do it this way so that we simulate many different growth trajectories in the population, averaged together.
  nLinfs = 1000 # how many different values of Linf to simulate
  
### create Matrices of simulated sizes
  Linfs <- rnorm(n = nLinfs, mean = pars$Linf, sd = (pars$Linf.cv *pars$Linf)) # vector of random dist. of Linfs- max lengths
  Linf_sims <- matrix(Linfs, nrow = nLinfs, ncol = length(x)) # expand into a matrix so there is a corresponding value of Linf for each possible value in the length vector x
  # ^ same values for each column to run against different size distr.
  Size_chge <- t(matrix(x, ncol = nLinfs, nrow = length(x))) # expand x into a matrix so there is a value for each value of Linfs.mat ## size changes per column and goes up to mesh max size 

### Create range of growth rates
  VBlengths <-  Linf_sims - (Linf_sims - Size_chge) * exp(-pars$K * timestep) # VonBert -- use those two matrices to get the range of possible growth rates, as a function of X
  
  VBmean <- colMeans(VBlengths) # Take the mean across all of the different trajectories for each value of x
  Leng_mean <- t(matrix(VBmean, nrow = length(x), ncol = length(x))) # expand into a matrix with a corresponding value for each value of Y (the size at time t+1)
  
  VBsd <- VBmean * (pars$Linf.cv)
  Leng_sd <- t(matrix(VBsd, nrow = length(x), ncol = length(x))) 
 
### convert to probability 
  pg <- dnorm(Size_r, mean = Leng_mean, sd = Leng_sd) # use dnorm to get the distribution of growth rates 
  pg[pg<0] = 0 # make sure no negatives
  
### Run the kernel as prob. death * growth
  K = pm * pg 
  
    Fec <- pars$fec.const * Size_c ^(pars$fec.exp)  #leads to much smaller values than sample IPM 
  Fe <- Fec * Rvec # combine the two
  
    time = 1000
    N = matrix(0, nrow = zzz[i], ncol = time) #pop size w/ growth/mortal kernel
    E = matrix(0, nrow = zzz[i], ncol = time) #pop size w/ ^^ & fecundity
  
    N[,1] <- Rvec * 1000 #* pars$Rmu  initialize with one pulse of new recruits
  
  ### Run the model
    for (t in 2:time){
      N[,t] <- K %*% N[,t-1] * dx  #+  Rvec  * pars$Rmu # midpoint rule integration
       E[,t] <- Fe %*% N[,t-1] * dx
      Eggs = sum(E[,t])*dx
      Recruits <- (4 * pars$steep * exp(pars$R0) * Eggs) / ((pars$S0 * (1 - pars$steep)) + (Eggs * (5 * pars$steep - 1)))
      
      N[,t] = N[,t] + Recruits * Rvec 
      
   ### total population size:
    MR <- sum(N[ ,time] * dx)
    abund[i] <- MR
 }
 abund ; z 


}
par(mfrow= c(1,2))
plot(z, type='l')
plot(abund, type='l')
```